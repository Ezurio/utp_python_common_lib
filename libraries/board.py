from lc_util import logger_get
from enum import Enum

logger = logger_get(__name__)


class dotdict(dict):
    # dot.notation access to dictionary attributes
    # http://stackoverflow.com/questions/2352181/how-to-use-a-dot-to-access-members-of-dictionary
    __getattr__ = dict.get
    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__

    def __init__(self, in_dict: dict):
        assert isinstance(in_dict, dict)
        for key, val in in_dict.items():
            if isinstance(val, (list, tuple)):
                setattr(self, key, [dotdict(x) if isinstance(
                    x, dict) else x for x in val])
            else:
                setattr(self, key, dotdict(val)
                        if isinstance(val, dict) else val)


class DebugProbeType(Enum):
    DVKPROBE = 0x00  # Laird Connectivity DVK Probe (RP2040)
    JLINK = 0x01  # Segger J-Link


class ComPortType(Enum):
    REPL = 0x00  # Python REPL serial port
    ZEPHYR = 0x01  # Zephyr shell serial port


class ComPortSource(Enum):
    # COM port is generated by the device/module (USB)
    DEVICE = 0x00
    # COM port is generated by the board (FTDI, debug probe, etc.)
    BOARD = 0x01


class ComPort(dotdict):
    sn: str
    index: int
    type: str
    source: str
    name: str | None
    device: str


class DebugProbe(dotdict):
    sn: str
    type: str
    name: str | None


class GenericBoard(dotdict):
    name: str | None
    ports: list[ComPort]
    probe: DebugProbe | None


class Board(object):
    """
    This is the base class for different boards.

    It contains methods for common functions and stubs for those that must
    be implemented by subclasses.
    """

    def __init__(self, id: str = ''):
        self.__initialized = False
        self.__id = id

    def __del__(self):
        try:
            self.close_ports()
        except:
            pass

    @property
    def board_name(self):
        """
        Board names match the class name.
        """
        return self.__class__.__name__

    @property
    def is_initialized(self):
        return self.__initialized

    @property
    def _initialized(self):
        return self.__initialized

    @_initialized.setter
    def _initialized(self, v: bool):
        """
        Allow subclass to set flag after it has completed initialization.
        """
        self.__initialized = v

    @classmethod
    def get_connected(cls, allow_list: list[str] = list(), boards_conf: list[GenericBoard] = list()) -> list:
        """Look for all boards in the current scope.

        Args:
            allow_list (list[str], optional): A list of class names that can be
            used to filter results. Any empty list allows all subclasses.
            Defaults to list().

            boards_conf (list[GenericBoard], optional): List of board configs to
            search for and create. Defaults to list().

        Returns:
            list: List of connected boards
        """
        if type(allow_list) == str:
            raise ValueError("Allow list must be list not str")

        boards = list()
        for subclass in cls.__subclasses__():
            logger.debug(subclass.__name__)
            boards.extend(subclass.get_connected(allow_list, boards_conf))

        return boards

    @staticmethod
    def get_single(boards_conf: list[GenericBoard] = list()):
        """Helper method to get a single board, or prompt user to select a board
        in the case of multiples.

        Args:
            boards_conf (list[GenericBoard], optional): List of board configs to
            search for and create. Defaults to list().

        Returns:
            board: the connected board
        """
        board = None
        boards = Board.get_connected(boards_conf=boards_conf)
        if len(boards) == 0:
            raise Exception(f"Error!  No Boards found.")

        choice = 0
        if len(boards) > 1:
            print("Which board do you want to use?")
            for i, board in enumerate(boards):
                print(f"{i}: {board}")
            choice = int(input("Enter the number of the board: "))
        if choice > (len(boards) - 1):
            raise Exception(f"Error!  Invalid Board Number.")

        return boards[choice]

    @staticmethod
    def get_by_com_port(com_port: str, boards_conf: list[GenericBoard] = list()):
        """Get a board that uses the specified COM port.

        Args:
            com_port (str): COM port device name
            boards_conf (list[GenericBoard], optional): List of board configs to
            search for and create. Defaults to list().

        Returns:
            board: The connected board or None if not found
        """
        for board in Board.get_connected(boards_conf=boards_conf):
            for _, port in board.ports.items():
                logger.debug(f"{_} {port}")
                try:
                    if port == com_port:
                        return board
                except:
                    pass

        return None

    @property
    def unique_id(self):
        return self.__id

    def open_and_init_board(self):
        """
        Opens the probe, UARTs, and resets the module.
        The probe and UARTs can then be accessed via the class properties.
        \n
        One purpose of this function is to defer some operations until
        after board discovery. However, some boards may not be able to be
        identified without connecting to them.
        """
        raise NotImplementedError

    def close_ports(self):
        """
        Close all UARTs. Boards may have different UARTs.
        """
        raise NotImplementedError

    def close_ports_and_reset(self, reset_probe: bool = True):
        """Close all UARTs and reset the probe and module.

        Args:
            reset_probe (bool, optional): reset the debug probe. Defaults to True.
        """

        raise NotImplementedError

    def reset_module(self):
        """
        Reset the module using the debug probe.
        """
        raise NotImplementedError

    def soft_reset_module(self):
        """
        Send end-of-transmission character to the board using Python UART
        """
        raise NotImplementedError
