from enum import Enum
import inspect
from lc_util import logger_get
import platform
import subprocess
import time

logger = logger_get(__name__)


class dotdict(dict):
    # dot.notation access to dictionary attributes
    # http://stackoverflow.com/questions/2352181/how-to-use-a-dot-to-access-members-of-dictionary
    __getattr__ = dict.get
    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__

    def __init__(self, in_dict: dict):
        assert isinstance(in_dict, dict)
        for key, val in in_dict.items():
            if isinstance(val, (list, tuple)):
                setattr(self, key, [dotdict(x) if isinstance(
                    x, dict) else x for x in val])
            else:
                setattr(self, key, dotdict(val)
                        if isinstance(val, dict) else val)


class DebugProbeType(Enum):
    DVKPROBE = 0x00  # Ezurio DVK Probe (RP2040)
    JLINK = 0x01  # Segger J-Link
    USB_SWD = 0x02 # Ezurio Programming Kit

class ComPortType(Enum):
    REPL = 0x00  # Python REPL serial port
    ZEPHYR = 0x01  # Zephyr shell serial port


class ComPortSource(Enum):
    # COM port is generated by the device/module (USB)
    DEVICE = 0x00
    # COM port is generated by the board (FTDI, debug probe, etc.)
    BOARD = 0x01


class Properties(Enum):
    """
    Only the names of the properties are used.
    """
    DUT = -1
    BLE = 0
    UWB = 1
    # The board's click interface is configured for the GPIO test
    GPIO_CLICK = 2
    # The board's click interface is configured for the I2C test
    I2C_CLICK = 3
    # The board's click interface is configured for the SPI test
    SPI_CLICK = 4
    # The board is a USB dongle
    USB_DONGLE = 5
    # The board supports the Zephyr shell
    ZEPHYR_SHELL = 6
    # The board supports the MicroPython Bluetooth GATT client
    GATT_CLIENT = 7
    # The board supports the MicroPython Bluetooth GATT server
    GATT_SERVER = 8
    # The board supports the SMP OS management group
    SMP_OS = 9
    # The board supports the SMP filesystem management group
    SMP_FILE = 10
    # The board supports the SMP image management group
    SMP_IMG = 11


class ComPort(dotdict):
    sn: str
    index: int
    type: str
    source: str
    name: str | None
    device: str


class DebugProbe(dotdict):
    sn: str
    type: str
    name: str | None


class BoardConfig(dotdict):
    name: str | None
    ports: list[ComPort]
    probe: DebugProbe | None
    properties: list | None


class Board(object):
    """
    This is the base class for different boards.

    It contains methods for common functions and stubs for those that must
    be implemented by subclasses.
    """
    #: :meta hide-value:
    #:
    #: Amount of time to wait after board reset before trying to open com port
    DEFAULT_COM_PORT_DELAY_SECONDS = 0.5
    #: :meta hide-value:
    #:
    #: Amount of time to wait after board reset before trying to open com port
    #: when the com port is from the device.
    DEFAULT_COM_PORT_FROM_DEVICE_DELAY_SECONDS = 6
    USB_ENUMERATION_DELAY = DEFAULT_COM_PORT_FROM_DEVICE_DELAY_SECONDS
    #: :meta hide-value:
    #:
    #: Amount of time to wait after board reset before trying to use/flush com port.
    BOOT_TIME_SECONDS = 5.0
    #: :meta hide-value:
    #:
    #: Without scripts the board boots in about 4 seconds. With scripts 8+ seconds.
    BOOT_TIME_SECONDS_RS2XX = 10.0
    
    def __init__(self, id: str = ''):
        self.__initialized = False
        self.__id = id

    def __del__(self):
        try:
            self.close_ports()
        except:
            pass

    @property
    def board_name(self):
        """
        Board names match the class name.
        """
        return self.__class__.__name__

    @property
    def is_initialized(self):
        return self.__initialized

    @property
    def _initialized(self):
        return self.__initialized

    @_initialized.setter
    def _initialized(self, v: bool):
        """
        Allow subclass to set flag after it has completed initialization.
        """
        self.__initialized = v

    @classmethod
    def get_connected(cls, allow_list: list[str] = list()) -> list:
        """Look for all boards in the current scope.

        Args:
            allow_list (list[str], optional): A list of class names that can be
            used to filter results. Any empty list allows all subclasses.
            Defaults to list().

        Returns:
            list: List of connected boards
        """
        if type(allow_list) == str:
            raise ValueError("Allow list must be list not str")

        boards = list()
        for subclass in cls.__subclasses__():
            logger.debug(subclass.__name__)
            if inspect.getsource(subclass).find("get_connected") != -1:
                boards.extend(subclass.get_connected(allow_list))

        return boards

    @classmethod
    def get_specified(cls, boards_conf: list[BoardConfig]) -> list:
        """Look for all boards in the current scope that match the specified configuration.

        Args:
            boards_conf (list[BoardConfig]): List of board configs to
            search for and create.
        """
        boards = list()
        if len(boards_conf) < 0:
            logger.warning("No board configurations provided")
            return boards

        for subclass in cls.__subclasses__():
            if inspect.getsource(subclass).find("get_specified") != -1:
                logger.info(subclass.__name__)
                b = subclass.get_specified(boards_conf)
                logger.info(f"Boards found: {len(b)}")
                boards.extend(b)

        return boards

    @staticmethod
    def get_single(boards_conf: list[BoardConfig] = list()):
        """Helper method to get a single board, or prompt user to select a board
        in the case of multiples.

        Args:
            boards_conf (list[BoardConfig], optional): List of board configs to
            search for and create. Defaults to list().

        Returns:
            board: the connected board
        """
        if len(boards_conf) > 0:
            boards.extend(Board.get_specified(boards_conf))
        else:
            boards = Board.get_connected()

        if len(boards) == 0:
            raise Exception(f"Error!  No Boards found.")

        choice = 0
        if len(boards) > 1:
            print("Which board do you want to use?")
            for i, board in enumerate(boards):
                print(f"{i}: {board}")
            choice = int(input("Enter the number of the board: "))
        if choice > (len(boards) - 1):
            raise Exception(f"Error!  Invalid Board Number.")

        return boards[choice]

    @staticmethod
    def get_by_com_port(com_port: str):
        """Get a board that uses the specified COM port.

        Args:
            com_port (str): COM port device name

        Returns:
            board: The connected board or None if not found
        """
        for board in Board.get_connected():
            for _, port in board.ports.items():
                logger.debug(f"{_} {port}")
                try:
                    if port == com_port:
                        return board
                except:
                    pass

        return None

    @classmethod
    def matches_name(cls, name: str):
        return cls.__name__.casefold() == name.casefold().replace(" ", "").replace("_", "")

    @classmethod
    def in_name(cls, name: str):
        return cls.__name__.casefold() in name.casefold().replace(" ", "").replace("_", "")

    @property
    def unique_id(self):
        return self.__id

    def open_and_init_board(self):
        """
        Opens the probe, UARTs, and resets the module.
        The probe and UARTs can then be accessed via the class properties.
        \n
        One purpose of this function is to defer some operations until
        after board discovery. However, some boards may not be able to be
        identified without connecting to them.
        """
        raise NotImplementedError

    def open_ports(self):
        """
        Open all UARTs. Boards may have different UARTs.
        """
        raise NotImplementedError

    def close_ports(self):
        """
        Close all UARTs. Boards may have different UARTs.
        """
        raise NotImplementedError

    def close_ports_and_reset(self, reset_probe: bool = True):
        """Close all UARTs and reset the probe and module.

        Args:
            reset_probe (bool, optional): reset the debug probe. Defaults to True.
        """
        raise NotImplementedError

    def reset_module(self):
        """
        Reset the module using the debug probe (hard) or Python UART (soft).
        """
        raise NotImplementedError

    def soft_reset_module(self):
        """
        Send end-of-transmission character to the board using Python UART.
        """
        raise NotImplementedError

    def program_mcu(self, file_path: str, board_name: str):
        """Program the microprocessor with a file.

        Args:
            file_path (str): The file to program
            board_name (str): A name that matches the class name (after conversion).
        """
        raise NotImplementedError

    @staticmethod
    def refresh_serial_ports():
        """
        On Linux, refresh the serial ports.
        """
        if platform.system() == 'Linux':
            command = ["sudo", "udevadm", "trigger", "--action=change"]
            process = subprocess.run(command, capture_output=True, text=True)
            logger.info(f"command: {process.args}")
            logger.info(f"status: {process.returncode}")
            logger.debug(f"{process.stdout=}")
            logger.debug(f"{process.stderr=}")
            assert process.returncode == 0, f"failed: {process.stderr}"
